# Fundamentos del lenguaje Haskell

## ¬øQu√© es programaci√≥n funcional?

En inform√°tica, la programaci√≥n funcional es un paradigma de programaci√≥n en donde los programas se componen de la aplicaci√≥n y composici√≥n de funciones. A diferencia de la programaci√≥n imperativa, donde se define una secuencia de instrucciones que cambian el estado del programa, en la programaci√≥n funcional se enfatiza el uso de funciones puras y la inmutabilidad de los datos.

A grandes rasgos, el paradigma funcional consiste en que las funciones son ciudadanos de primer orden, esto quiere decir que, funciones pueden recibir como argumento otras funciones, las funciones pueden tener como valor de retorno otras funciones, y las funciones pueden ser asignadas a variables. Adem√°s, la programaci√≥n funcional promueve el uso de funciones puras, que son aquellas que no tienen efectos secundarios y siempre devuelven el mismo resultado para los mismos argumentos.

## Hello World en Haskell

Para crear un proyecto en Haskell vamos a usar en esta ocasi√≥n **Stack**, el cual es un gestor de proyectos y dependencias para Haskell, similar a lo que es **npm** para JavaScript o **pip** para Python.

Para esto vamos a ejecutar los siguientes comandos en la terminal:

```bash
# Crear un nuevo proyecto
stack new hello-world
```

Esto nos crear√° una carpeta llamada `hello-world` con la siguiente estructura:

```text
C:.
|   .gitignore
|   CHANGELOG.md
|   hello-world.cabal
|   LICENSE
|   package.yaml
|   README.md
|   Setup.hs
|   stack.yaml
|
+---app
|       Main.hs
|
+---src
|       Lib.hs
|
\---test
        Spec.hs
```

El archivo `Main.hs` es el punto de entrada de nuestra aplicaci√≥n, y es donde vamos a escribir nuestro primer programa en Haskell.

Contiene el siguiente c√≥digo:

```haskell
module Main (main) where

import Lib

main :: IO ()
main = someFunc
```

### Disecci√≥n del c√≥digo

Analicemos l√≠nea por l√≠nea nuestro primer programa en Haskell:

```haskell
module Main (main) where
```

**üèóÔ∏è `module Main`**: Define un **m√≥dulo** llamado `Main`. Los m√≥dulos son como namespaces - organizan y agrupan funciones relacionadas. El m√≥dulo `Main` es especial porque es el punto de entrada de nuestra aplicaci√≥n.

**üì§ `(main)`**: Lista de **exportaci√≥n** - especifica qu√© funciones de este m√≥dulo pueden ser usadas por otros m√≥dulos. Solo exportamos `main` porque es lo √∫nico que necesita el mundo exterior.

**üîó `where`**: Palabra clave que introduce las definiciones del m√≥dulo. Todo lo que viene despu√©s pertenece a este m√≥dulo.

```haskell
import Lib
```

**üì• `import Lib`**: Importa todas las funciones p√∫blicas del m√≥dulo `Lib` (ubicado en `src/Lib.hs`). Es como `import` en Python o `require` en Node.js, pero m√°s poderoso - puedes importar funciones espec√≠ficas, renombrarlas, etc.

```haskell
main :: IO ()
```

**üéØ Signatura de tipo**: `main` es una funci√≥n que:

- **`IO`**: Realiza operaciones de entrada/salida (input/output)
- **`()`**: No retorna un valor √∫til (equivalente a `void` en otros lenguajes)
- **`::`**: Se lee como "tiene tipo" - separa el nombre de la funci√≥n de su tipo

```haskell
main = someFunc
```

**‚öôÔ∏è Definici√≥n de funci√≥n**: `main` simplemente llama a `someFunc` (definida en el m√≥dulo `Lib`). En Haskell, el signo `=` no es asignaci√≥n - es **definici√≥n**. Estamos diciendo que `main` **es** `someFunc`.

### ü§î Conceptos que Apuntan al Futuro

- **üì¶ M√≥dulos**: Sistema de organizaci√≥n m√°s poderoso que clases
- **üîç Tipos expl√≠citos**: Haskell puede inferir tipos, pero escribirlos es buena pr√°ctica
- **üåä IO Monad**: Forma elegante de manejar efectos secundarios en un lenguaje puro
- **üé≠ Funciones como valores**: `main = someFunc` trata funciones como datos

```haskell
module Lib
    ( someFunc
    ) where

someFunc :: IO ()
someFunc = putStrLn "Hello Haskell!"
```

### üîç An√°lisis del m√≥dulo Lib

```haskell
module Lib
    ( someFunc
    ) where
```

**üìã Exportaci√≥n expl√≠cita**: A diferencia de `Main` que exportaba solo una funci√≥n, aqu√≠ vemos la sintaxis **multil√≠nea** para exportaciones. Los par√©ntesis pueden contener m√∫ltiples funciones separadas por comas - muy √∫til cuando tu m√≥dulo crece.

```haskell
someFunc :: IO ()
someFunc = putStrLn "someFunc"
```

**üñ®Ô∏è `putStrLn`**: Funci√≥n integrada de Haskell que:

- **`put`**: Poner/colocar
- **`Str`**: String (cadena de texto)
- **`Ln`**: Line (nueva l√≠nea al final)

Es el equivalente a `console.log()` en JavaScript o `print()` en Python, pero **type-safe**.

**üéØ Primera funci√≥n real**: `someFunc` no solo llama a otra funci√≥n - **es** la llamada a `putStrLn`. En Haskell, `putStrLn "someFunc"` es una **acci√≥n** que, cuando se ejecuta, imprime texto.

### üöÄ Conceptos Nuevos

- **üè≠ Funciones de librer√≠a**: `putStrLn` viene de la librer√≠a est√°ndar
- **üìù Acciones vs Valores**: `putStrLn "texto"` es una **acci√≥n IO**, no un string
- **üîó Composici√≥n simple**: Un m√≥dulo puede ser tan simple como una funci√≥n que llama a otra

### ü§î ¬øPor qu√© separar Main y Lib?

- **üéØ Main**: Punto de entrada, orquesta la aplicaci√≥n
- **üìö Lib**: L√≥gica reutilizable, funciones puras
- **üß™ Separaci√≥n**: Facilita testing y reutilizaci√≥n

## Ejecutando el programa

Para ejecutar nuestro programa, primero debemos asegurarnos de estar en la carpeta del proyecto `hello-world`. Luego, abrimos Visual Studio Code desde esa carpeta para trabajar c√≥modamente.

```bash
# Navegar a la carpeta del proyecto
cd hello-world
# Abrir Visual Studio Code desde aqu√≠
code .
```

Una vez dentro de Visual Studio Code, abrimos la terminal integrada y ejecutamos los siguientes comandos para compilar y ejecutar nuestro programa:

```bash
# Desde dentro de hello-world/
stack build
stack exec hello-world-exe
```

Esto compilar√° nuestro proyecto y ejecutar√° el programa, mostrando el mensaje "Hello Haskell!" en la terminal.

### Sobre la estructura del proyecto

Stack genera una estructura de proyecto profesional que sigue las mejores pr√°cticas de Haskell. Veamos qu√© hace cada archivo y carpeta:

#### üìÑ Archivos de Configuraci√≥n (Ra√≠z)

**üìã `package.yaml`**: Archivo principal de configuraci√≥n del proyecto

- Define metadatos (nombre, versi√≥n, autor)
- Lista dependencias del proyecto
- Especifica configuraci√≥n de compilaci√≥n
- **Es como `package.json` en Node.js**

**‚öôÔ∏è `stack.yaml`**: Configuraci√≥n espec√≠fica de Stack

- Especifica qu√© versi√≥n del compilador GHC usar
- Define el "resolver" (conjunto de paquetes compatibles)
- Configuraci√≥n de build local

**üì¶ `hello-world.cabal`**: Archivo generado autom√°ticamente

- **NO editar manualmente** - Stack lo genera desde `package.yaml`
- Formato tradicional de Cabal
- Es lo que GHC realmente lee para compilar

#### üìö Documentaci√≥n y Metadatos

**üìñ `README.md`**: Documentaci√≥n del proyecto

- Descripci√≥n del proyecto
- Instrucciones de instalaci√≥n y uso
- **Personal√≠zalo** para describir tu aplicaci√≥n

**üìù `CHANGELOG.md`**: Historial de cambios

- Documenta nuevas features, fixes, breaking changes
- Fundamental para librer√≠as p√∫blicas

**‚öñÔ∏è `LICENSE`**: Licencia del proyecto

- Por defecto usa BSD3 (muy permisiva)
- Define c√≥mo otros pueden usar tu c√≥digo

#### üîß Archivos de Build

**üî® `Setup.hs`**: Script de configuraci√≥n de Cabal

- Raramente necesitas editarlo
- Permite customizaci√≥n avanzada del proceso de build

**üö´ `.gitignore`**: Archivos que Git debe ignorar

- Excluye archivos compilados (`.hi`, `.o`)
- Excluye carpeta `dist/` y `.stack-work/`

#### üìÅ Estructura de C√≥digo

**üöÄ `app/`**: C√≥digo de la aplicaci√≥n ejecutable

- **`Main.hs`**: Punto de entrada principal
- Solo contiene l√≥gica de arranque
- Llama a funciones definidas en `src/`

**üìö `src/`**: C√≥digo de librer√≠as reutilizables

- **`Lib.hs`**: Funciones principales del proyecto
- L√≥gica de negocio
- C√≥digo que puede ser importado por otros m√≥dulos

**üß™ `test/`**: Tests unitarios e integraci√≥n

- **`Spec.hs`**: Tests usando HSpec
- Stack puede ejecutar con `stack test`
- Fundamental para c√≥digo de calidad

#### üéØ Flujo de Trabajo T√≠pico

```
üìù Escribes l√≥gica en src/
    ‚Üì
üöÄ La llamas desde app/Main.hs
    ‚Üì
üß™ La testeas en test/
    ‚Üì
üì¶ Stack compila todo junto
```

#### üí° Ventajas de esta Estructura

- **üîÑ Separaci√≥n clara**: App vs Librer√≠a vs Tests
- **üì¶ Reutilizaci√≥n**: `src/` puede ser usado por otros proyectos
- **üß™ Testing**: Tests aislados de la aplicaci√≥n
- **üìö Documentaci√≥n**: Todo bien organizado y documentado

**¬°Esta estructura escala desde "Hello World" hasta aplicaciones enterprise!** üöÄ

## üßÆ Proyecto: Calculadora B√°sica

Ahora que entendemos la estructura b√°sica, vamos a crear nuestro primer proyecto pr√°ctico: una calculadora que nos ense√±ar√° los fundamentos de Haskell.

### üéØ Objetivos del Proyecto

- ‚úÖ Escribir funciones puras
- ‚úÖ Entender tipos b√°sicos (`Int`, `Double`, `Bool`)
- ‚úÖ Usar signatura de tipos
- ‚úÖ Probar funciones en GHCi
- ‚úÖ Manejar operaciones matem√°ticas

### üöÄ Setup del Proyecto

Vamos a trabajar directamente en nuestro proyecto `hello-world` modificando los archivos existentes:

```bash
# Aseg√∫rate de estar en la carpeta del proyecto
cd hello-world

# Abrir en VSCode
code .
```

### üìù Creando la Calculadora

Edita el archivo `src/Lib.hs`:

```haskell
-- src/Lib.hs
module Lib
    ( sumar
    , restar
    , multiplicar
    , dividir
    , potencia
    , areaCirculo
    , areaRectangulo
    , mostrarCalculadora
    ) where

-- ========================================
-- OPERACIONES B√ÅSICAS
-- ========================================

-- Suma de dos n√∫meros
sumar :: Double -> Double -> Double
sumar x y = x + y

-- Resta de dos n√∫meros
restar :: Double -> Double -> Double
restar x y = x - y

-- Multiplicaci√≥n de dos n√∫meros
multiplicar :: Double -> Double -> Double
multiplicar x y = x * y

-- Divisi√≥n de dos n√∫meros (cuidado con el cero)
dividir :: Double -> Double -> Double
dividir x y = x / y

-- Potencia (base elevada a exponente)
potencia :: Double -> Double -> Double
potencia base exponente = base ** exponente

-- ========================================
-- FUNCIONES GEOM√âTRICAS
-- ========================================

-- √Årea de un c√≠rculo
areaCirculo :: Double -> Double
areaCirculo radio = pi * radio * radio

-- √Årea de un rect√°ngulo
areaRectangulo :: Double -> Double -> Double
areaRectangulo largo ancho = largo * ancho

-- ========================================
-- FUNCI√ìN DEMO
-- ========================================

-- Funci√≥n que muestra ejemplos de la calculadora
mostrarCalculadora :: IO ()
mostrarCalculadora = do
    putStrLn "=== üßÆ CALCULADORA HASKELL ==="
    putStrLn ""
    putStrLn "Operaciones b√°sicas:"
    putStrLn ("5 + 3 = " ++ show (sumar 5 3))
    putStrLn ("10 - 4 = " ++ show (restar 10 4))
    putStrLn ("6 * 7 = " ++ show (multiplicar 6 7))
    putStrLn ("15 / 3 = " ++ show (dividir 15 3))
    putStrLn ("2 ^ 8 = " ++ show (potencia 2 8))
    putStrLn ""
    putStrLn "Funciones geom√©tricas:"
    putStrLn ("√Årea c√≠rculo (radio=5): " ++ show (areaCirculo 5))
    putStrLn ("√Årea rect√°ngulo (4x6): " ++ show (areaRectangulo 4 6))
```

### üéØ Actualizando Main.hs

Edita `app/Main.hs` para usar nuestra calculadora:

```haskell
-- app/Main.hs
module Main (main) where

import Lib

main :: IO ()
main = do
    putStrLn "¬°Bienvenido a Haskell! üéâ"
    putStrLn ""
    mostrarCalculadora
```

### üèÉ‚Äç‚ôÇÔ∏è Ejecutando la Calculadora

```bash
# Compilar y ejecutar
stack build
stack exec hello-world-exe
```

**Salida esperada:**

```
¬°Bienvenido a Haskell! üéâ

=== üßÆ CALCULADORA HASKELL ===

Operaciones b√°sicas:
5 + 3 = 8.0
10 - 4 = 6.0
6 * 7 = 42.0
15 / 3 = 5.0
2 ^ 8 = 256.0

Funciones geom√©tricas:
√Årea c√≠rculo (radio=5): 78.53981633974483
√Årea rect√°ngulo (4x6): 24.0
```

### üéÆ Jugando en el REPL

La verdadera diversi√≥n est√° en el REPL. Abre GHCi en tu proyecto:

```bash
stack ghci
```

Ahora puedes usar tu calculadora interactivamente:

```haskell
-- Cargar tu m√≥dulo
*Main Lib> :load src/Lib.hs

-- Probar funciones
*Main Lib> sumar 15 25
40.0

*Main Lib> potencia 3 4
81.0

*Main Lib> areaCirculo 10
314.1592653589793

-- Ver el tipo de una funci√≥n
*Main Lib> :type sumar
sumar :: Double -> Double -> Double

-- Aplicaci√≥n parcial (¬°magia funcional!)
*Main Lib> let sumar5 = sumar 5
*Main Lib> sumar5 10
15.0

-- Composici√≥n de funciones
*Main Lib> sumar (multiplicar 3 4) (potencia 2 3)
20.0
```

### üß™ Experimentos en REPL

Prueba estos experimentos para entender mejor Haskell:

```haskell
-- 1. Aplicaci√≥n parcial
*Main Lib> let doble = multiplicar 2
*Main Lib> doble 7
14.0

-- 2. Funciones como argumentos (adelanto del futuro)
*Main Lib> map (multiplicar 3) [1, 2, 3, 4]
[3.0,6.0,9.0,12.0]

-- 3. Inferencia de tipos
*Main Lib> :type 42
42 :: Num a => a

*Main Lib> :type 3.14
3.14 :: Fractional a => a

-- 4. Operadores como funciones
*Main Lib> (+) 5 3
8

*Main Lib> (*) 4
<interactive>:1:1: error: [GHC-83865]
    ‚Ä¢ No instance for (Show (Double -> Double))
```

### üìö Conceptos Clave Aprendidos

#### üéØ **Signatura de Tipos**

```haskell
sumar :: Double -> Double -> Double
--       ‚Üë        ‚Üë        ‚Üë
--    entrada1  entrada2  salida
```

#### üîÑ **Funciones Puras**

- Misma entrada ‚Üí Misma salida
- Sin efectos secundarios
- F√°ciles de testear y razonar

#### üßÆ **Aplicaci√≥n Parcial**

```haskell
sumar 5 3     -- Aplicaci√≥n total: 8.0
sumar 5       -- Aplicaci√≥n parcial: funci√≥n que espera un n√∫mero
```

#### üì¶ **Exportaci√≥n de M√≥dulos**

- Solo exportamos lo que otros necesitan usar
- Encapsulaci√≥n funcional

### üéØ Ejercicios para Practicar

1. **Agregar m√°s funciones matem√°ticas**:

   ```haskell
   raizCuadrada :: Double -> Double
   factorial :: Int -> Int
   ```

   > En Haskell, existe una diferencia entre `Int` e `Integer`. `Int` es un entero de tama√±o fijo (32 o 64 bits), mientras que `Integer` es un entero de precisi√≥n arbitraria. Para c√°lculos matem√°ticos simples, `Int` es suficiente, pero para n√∫meros muy grandes, usa `Integer`.

2. **Funciones de validaci√≥n**:

   ```haskell
   esPar :: Int -> Bool
   esPositivo :: Double -> Bool
   ```

3. **Conversor de unidades**:
   ```haskell
   celsiusAFahrenheit :: Double -> Double
   metrosAPies :: Double -> Double
   ```

---

> üí° En Haskell no hay variables que cambien, no hay loops, no hay mutaci√≥n. Solo funciones puras que transforman datos. ¬°Esto es programaci√≥n funcional en acci√≥n!
